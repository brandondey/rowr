{
    "contents" : "#' Row-based functions for R objects.\n#'\n#' Rowr allows the manipulation of R objects as if they were organized rows in a\n#' way that is familiar to people used to working with databases.  It allows\n#' more consistent and predictable output to common functions, and generalizes a\n#' number of utility functions to to be failsafe with any number of objects.\n#' @name rowr\n#' @docType package\nNULL\n\n\n#' Vectorize a scalar function to work on any R object.\n#' \n#' Robust alternative to \\code{\\link{Vectorize}} function that accepts any function with two \n#' or more arguments.  Returns a function that will work an arbitrary number of vectors, lists or \n#' data frames, though output may be unpredicatable in unusual applications.  The \n#' results are also intended to be more intuitive than Vectorize.\n#' \n#' @param fun a two or more argument function\n#' @param type like \\code{MARGIN} in \\code{\\link{apply}}, except that \\code{c(1,2)} is\n#'   represented as a \\code{3} instead.  By default, will \\code{Reduce} single dimensional\n#'   data handle everything else row-wise.\n#' @export\n#' @examples\n#' vectorize(`+`)(c(1,2,3))\n#' vectorize(sum)(c(1,2,3),c(1,2,3))\n#' # Compare these results to Vectorize, which does not vectorize sum at all.\n#' Vectorize(sum)(c(1,2,3),c(1,2,3))\n#' # Across data frame columns.\n#' df<-data.frame(a=c(1,2,3),b=c(1,2,3))\n#' vectorize(sum)(df$a,df$b)\n#' # Once again, Vectorize gives a different result\n#' Vectorize(sum)(df$a,df$b)\n#' # Any combination of vectors, lists, matrices, or data frames an be used.\n#' vectorize(`+`)(c(1,2,3),list(1,2,3),cbind(c(1,2,3)))\nvectorize<-function(fun,type=NULL)\n{\n  function(...)\n  {\n    cols<-cbind.fill(...)\n    if(is.null(type))\n      if(dim(cols)[2]<2)\n        type=2\n      else\n        type=1\n    if(type==3)\n      margin=c(1,2)\n    else\n      margin=type\n    if(type %in% c(1,2,3))\n      apply(cols,margin,function (x) Reduce(fun,unlist(x)))\n    else\n      Reduce(fun,unlist(cols))\n  }  \n}\n\n\n#'Pads an object to a desired length, either with replicates of itself or another repeated object.\n#'\n#'@param x an R object\n#'@param length.out the desired length of the final output\n#'@param fill R object to fill empty rows in columns below the max size.  If unspecified, repeats input rows in the same way as \\code{cbind}.\n#'@param preserveClass determines whether to return an object of the same class as the original argument.  Otherwise, returns a matrix.\n#'@export\n#'@examples\n#'buffer(c(1,2,3),20)\n#'buffer(matrix(c(1,2,3,4),nrow=2),20)\n#'buffer(list(1,2,3),20)\n#'df<-data.frame(as.factor(c('Hello','Goodbye')),c(1,2))\n#'buffer(df,5)\n#'buffer((factor(x=c('Hello'))),5)\nbuffer<-function(x,length.out=len(x),fill=NULL,preserveClass=TRUE)\n{\n  xclass<-class(x)\n  input<-vert(x)\n  results<-as.data.frame(sapply(input,rep,length.out=length.out))\n  if(length.out>len(x) && !is.null(fill))\n  {\n    results<-t(results)\n    results[(length(unlist(x))+1):length(unlist(results))]<-fill\n    results<-t(results)\n  }\n  if(preserveClass)\n    results<-as2(results,xclass)\n  return(results)   \n}\n\n\n#' Combine arbitrary data types, filling in missing rows.\n#' \n#' Robust alternative to \\code{\\link{cbind}} that fills missing values and works\n#' on arbitrary data types.  Combines any number of R objects into a single matrix, with each input\n#' corresponding to the greater of 1 or ncol.  \\code{cbind} has counterintuitive\n#' results when working with lists, cannot handle certain inputs of differing\n#' length, and does not allow the fill to be specified.\n#' \n#' @param ... any number of R data objects\n#' @param fill R object to fill empty rows in columns below the max size.  If unspecified, repeats input rows in the same way as \\code{cbind}. Passed to \\code{\\link{buffer}}.\n#' @export\n#' @examples\n#' cbind.fill(c(1,2,3),list(1,2,3),cbind(c(1,2,3)))\n#'df<-data.frame(a=c(1,2,3),b=c(1,2,3))\n#' cbind.fill(c(1,2,3),list(1,2,3),cbind(c('a','b')),'a',df)\n#' cbind.fill(a=c(1,2,3),list(1,2,3),cbind(c('a','b')),'a',df,fill=NA)\ncbind.fill<-function(...,fill=NULL)\n{\n  inputs<-list(...)\n  maxlength<-max(unlist(lapply(inputs,len)))\n  bufferedInputs<-lapply(inputs,buffer,length.out=maxlength,fill,preserveClass=FALSE)\n  return(Reduce(cbind.data.frame,bufferedInputs))\n}\n\n#'Allows row indexing without knowledge of dimensionality or class.\n#'\n#'@param data any \\code{R} object\n#'@param rownums indices of target rows\n#'@export\n#'@examples\n#'rows(c('A','B','C'),c(1,3))\n#'rows(list('A','B','C'),c(1,3))\n#'df<-data.frame(a=c(1,2,3),b=c(1,2,3))\n#'rows(df,3)\nrows <- function(data,rownums)\n{\n  #result<-data[rownums]\n  if(is.null(dim(data)))\n  {\n    result<-data[rownums]\n  }\n  else\n  {\n    result<-data[rownums,]\n  }\n  #result<-ifelse(is.null(dim(data)),data[c(rownums)],data[c(rownums),])\n  return((result))\n}\n\n#'Allows finding the 'length' without knowledge of dimensionality.\n#'\n#'@param data any \\code{R} object\n#'@export\n#'@examples\n#'len(list(1,2,3))\n#'len(c(1,2,3,4))\n#'df<-data.frame(a=c(1,2,3),b=c(1,2,3))\n#'len(df)\nlen <- function(data)\n{\n  result<-ifelse(is.null(nrow(data)),length(data),nrow(data))\n  return(result)\n}\n\n\n#' A more versatile form of the T-SQL \\code{coalesce()} function.  \n#'\n#' Little more than a wrapper for \\code{\\link{vectorize}}, allows for duplication of SQL coalesce functionality, certain types of if-else statements, and \\code{\\link{apply}}/\\code{\\link{Reduce}} combinations.\n#' \n#' @param ... an arbitrary number of \\code{R} objects\n#' @param fun a two argument function that returns an atomic value\n#' @export\n#' @examples\n#' coalesce(c(NA,1,2))\n#' coalesce(c(NA,1,2),c(3,4,NA))\n#' df<-data.frame(a=c(NA,2,3),b=c(1,2,NA))\n#' coalesce(df$a,df$b)\n#' # Or even just:\n#' coalesce(df)\n#' # Coalesce can actually use any comparison.  For example, instead of non-NA values it could find the max in each row:\n#' cbind(EuStockMarkets,Max=coalesce(EuStockMarkets,fun=function (x,y) if (x>y) x else y))\ncoalesce<-function(...,fun=(function (x,y) if(!is.na(x)) x else y))\n{\n\n    FUN=match.fun(fun)\n    vectorize(FUN)(...)\n}\n\n#'A more versatile form of the T-SQL \\code{count()} function.\n#'\n#'Implementation of T-SQL \\code{count} and Excel \\code{COUNTIF} functions.  Shows the total number of elements in any number of data objects altogether or that match a condition.\n#'\n#'@param ... an arbitrary number of \\code{R} objects\n#'@param condition a 1 argument condition\n#'@export\n#'@examples\n#'count(c(NA,1,2))\n#'count(c(NA,1,2),is.na)\n#'count(c(NA,1,2),list('A',4),cbind(1,2,3))\n#'count(c(NA,1,2),list('A',4),cbind(1,2,3),condition=is.character)\ncount<-function(...,condition=(function (x) TRUE))\n{\n  data<-c(...)\n  result<-sum(sapply(data, function (x) if(condition(x)) 1 else 0))\n  return(result)\n}\n\n#'Applies a function over a rolling window on any data object.\n#'\n#'Simple generalized alternative to \\code{\\link[zoo]{rollapply}} in package \\code{\\link[zoo]{zoo}} with the advantage that it works on any type of data structure (vector, list, matrix, etc) instead of requiring a \\code{zoo} object.\n#'\n#'@param data any \\code{R} object\n#'@param fun the function to evaluate\n#'@param window window width defining the size of the subset available to the fun at any given point\n#'@param minimum minimum width of the window.  Will not return results if the window is truncated below this value at the end of the data set\n#'@param align whether to align the window right or left\n#'@export\n#'@examples\n#'rollApply(1:100,sum,minimum=2,window=2)\n#'rollApply(c(1,2,3),sum)\n#'##6 5 3\n#'rollApply(c(1,2,3,4,5,6,7,8,9),sum)\n#'##45 44 42 39 35 30 24 17  9\n#'rollApply(c(1,2,3,4,5,6,7,8,9),sum,window=2)\n#'##3  5  7  9 11 13 15 17  9\n#'rollApply(list(1,2,3,4,5,6,7,8,9),function(x) sum(unlist(x)),window=2,minimum=2)\n#'##3  5  7  9 11 13 15 17\n#'cbind(women,Rolling3=rollApply(women,fun=function(x) mean(x$weight),window=3,align='right'))\n#'\nrollApply <- function(data,fun,window=len(data),minimum=1,align='left')\n{\n  if(minimum>len(data))\n    return()\n  FUN=match.fun(fun)\n  if (align=='left')\n    result<-sapply(1:(len(data)-minimum+1),function (x) FUN(rows(data,x:(min(len(data),(x+window-1))))))\n  if (align=='right')\n    result<-sapply(minimum:len(data),function (x) FUN(rows(data,max(1,x-window+1):x)))\n  return(result)\n}\n\n#'Applies a function row-wise on any data object.\n#'\n#'Essentially functions as a \\code{MARGIN=1} \\code{\\link{apply}} apply but also works on data objects without 2 dimensions such as lists and vectors.\n#'\n#'@param data any \\code{R} object\n#'@param fun the function to evaluate\n#'@param ... additional arguments to pass to \\code{fun}\n#'rowApply(list(1,2,3),function (x) sum(unlist(x)))\n#'rowApply(df,sum)\nrowApply<-function(data,fun,...)\n{\n  sapply(1:len(data),function (x) fun(rows(data,x),...))\n}\n\n#'A more robust form of the R \\code{\\link{as}} function.\n#'\n#' Alternative to \\code{as} that allows any data object to be converted to any other.  \n#'\n#'@param object any \\code{R} object\n#'@param class the name of the class to which \\code{object} should be coerced\nas2<-function(object,class)\n{\n  object<-as.matrix(object)\n  if(class=='factor')\n    return(as.factor(as.character(object)))\n  if(class=='data.frame')\n    return(as.data.frame(object))\n  else\n    return(as(object,class))\n}\n\nvert<-function(object)\n{\n   result<-as.data.frame(cbind(as.matrix(object)))\n   return(result)\n}",
    "created" : 1406043196234.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1292674339",
    "id" : "3279BC7D",
    "lastKnownWriteTime" : 1408476399,
    "path" : "~/Analytics/Source/rowr/R/rowr.R",
    "project_path" : "R/rowr.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}