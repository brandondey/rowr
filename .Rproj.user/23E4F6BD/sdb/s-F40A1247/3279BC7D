{
    "contents" : "#' Row-based functions for R objects.\n#'\n#' Rowr allows the manipulation of R objects as if they were organized rows in a\n#' way that is familiar to people used to working with databases.  It allows\n#' more consistent and predictable output to common functions, and generalizes a\n#' number of utility functions to to be failsafe with any number of objects.\n#' @name rowr\n#' @docType package\nNULL\n\n\n#' Vectorize a scalar function to work on any R object.\n#' \n#' Robust alternative to \\code{\\link{Vectorize}} function that accepts any function with two \n#' or more arguments.  Returns a function that will work an arbitrary number of vectors, lists or \n#' data frames, though output may be unpredicatable in unusual applications.  The \n#' results are also intended to be more intuitive than Vectorize.\n#' \n#' @param fun a two or more argument function\n#' @param type like \\code{MARGIN} in \\code{\\link{apply}}, except that \\code{c(1,2)} is\n#'   represented as a \\code{3} instead.  By default, will \\code{Reduce} single dimensional\n#'   data handle everything else row-wise.\n#' @export\n#' @examples\n#' vectorize(`+`)(c(1,2,3))\n#' vectorize(sum)(c(1,2,3),c(1,2,3))\n#' # Compare these results to Vectorize, which does not vectorize sum at all.\n#' Vectorize(sum)(c(1,2,3),c(1,2,3))\n#' # Across data frame columns.\n#' df<-data.frame(a=c(1,2,3),b=c(1,2,3))\n#' vectorize(sum)(df$a,df$b)\n#' # Once again, Vectorize gives a different result\n#' Vectorize(sum)(df$a,df$b)\n#' # Any combination of vectors, lists, matrices, or data frames an be used.\n#' vectorize(`+`)(c(1,2,3),list(1,2,3),cbind(c(1,2,3)))\nvectorize<-function(fun,type=NULL)\n{\n  function(...)\n  {\n    cols<-cbind.fill(...)\n    if(is.null(type))\n      if(dim(cols)[2]<2)\n        type=2\n      else\n        type=1\n    if(type==3)\n      margin=c(1,2)\n    else\n      margin=type\n    if(type %in% c(1,2,3))\n      apply(cols,margin,function (x) Reduce(fun,unlist(x)))\n    else\n      Reduce(fun,unlist(cols))\n  }  \n}\n\n\n#'Pads an object to a desired length, either with replicates of itself or another repeated object.\n#'\n#'@param x an R object\n#'@param length.out the desired length of the final output\n#'@param fill R object to fill empty rows in columns below the max size.  If unspecified, repeats input rows in the same way as \\code{cbind}.\n#'@param preserveClass determines whether to return an object of the same class as the original argument.  Otherwise, returns a matrix.\n#'@export\n#'@examples\n#'buffer(c(1,2,3),20)\n#'buffer(matrix(c(1,2,3,4),nrow=2),20)\n#'buffer(list(1,2,3),20)\nbuffer<-function(x,length.out=len(x),fill=NULL,preserveClass=TRUE)\n{\n  xclass<-class(x)\n  input<-data.frame(cbind(x))\n  results<-sapply(input,rep_len,length.out=length.out)\n  if(length.out>len(x) && !is.null(fill))\n  {\n    results<-t(results)\n    results[(length(unlist(x))+1):length(unlist(results))]<-fill\n    results<-t(results)\n  }\n  if(preserveClass)\n    if(xclass=='data.frame')\n      results<-as.data.frame(results)\n  else\n    results<-as(results,xclass)\n  return(results)   \n}\n\n\n#' Combine arbitrary data types, filling in missing rows.\n#' \n#' Robust alternative to \\code{\\link{cbind}} that fills missing values and works\n#' on arbitrary data types.  Combines any number of R objects into a single matrix, with each input\n#' corresponding to the greater of 1 or ncol.  \\code{cbind} has counterintuitive\n#' results when working with lists, cannot handle certain inputs of differing\n#' length, and does not allow the fill to be specified.\n#' \n#' @param ... any number of R data objects\n#' @param fill R object to fill empty rows in columns below the max size.  If unspecified, repeats input rows in the same way as \\code{cbind}. Passed to \\code{\\link{buffer}}.\n#' @export\n#' @examples\n#' cbind.fill(c(1,2,3),list(1,2,3),cbind(c(1,2,3)))\n#' cbind.fill(c(1,2,3),list(1,2,3),cbind(c('a','b')),'a',df)\n#' cbind.fill(c(1,2,3),list(1,2,3),cbind(c('a','b')),'a',df,fill=NA)\ncbind.fill<-function(...,fill=NULL)\n{\n  inputs<-list(...)\n  maxlength<-max(unlist(lapply(inputs,len)))\n  bufferedInputs<-lapply(inputs,buffer,length.out=maxlength,fill,preserveClass=FALSE)\n  return(Reduce(cbind,bufferedInputs))\n}\n\n#'Allows row indexing without knowledge of dimensionality or class.\n#'\n#'@param data any \\code{R} object\n#'@param rownums indices of target rows\n#'@export\n#'@examples\n#'rows(c('A','B','C'),c(1,3))\n#'rows(list('A','B','C'),c(1,3))\n#'df<-data.frame(a=c(1,2,3),b=c(1,2,3))\n#'rows(df,3)\nrows <- function(data,rownums)\n{\n  #result<-data[rownums]\n  if(is.null(dim(data)))\n  {\n    result<-data[rownums]\n  }\n  else\n  {\n    result<-data[rownums,]\n  }\n  #result<-ifelse(is.null(dim(data)),data[c(rownums)],data[c(rownums),])\n  return(result)\n}\n\n#'Allows finding the 'length' without knowledge of dimensionality.\n#'\n#'@param data any \\code{R} object\n#'@export\n#'\nlen <- function(data)\n{\n  result<-ifelse(is.null(nrow(data)),length(data),nrow(data))\n  return(result)\n}\n\n\n#' A more versatile form of the T-SQL \\code{coalesce()} function.  \n#'\n#' Little more than a wrapper for \\code{\\link{vectorize}}, allows for duplication of SQL coalesce functionality, certain types of if-else statements, and \\code{\\link{apply}}/\\code{\\link{Reduce}} combinations.\n#' \n#' @param ... an arbitrary number of \\code{R} objects\n#' @param fun a two argument function that returns an atomic value\n#' @export\n#' @examples\n#' coalesce(c(NA,1,2))\n#' coalesce(c(NA,1,2),c(3,4,NA))\n#' df<-data.frame(a=c(NA,2,3),b=c(1,2,NA))\n#' coalesce(df$a,df$b)\n#' # Or even just:\n#' coalesce(df)\ncoalesce<-function(...,fun=(function (x,y) if(!is.na(x)) x else y))\n{\n\n    FUN=match.fun(fun)\n    vectorize(FUN)(...)\n}\n\n#'A more versatile form of the T-SQL \\code{count()} function.\n#'\n#'Implementation of T-SQL \\code{count} and Excel \\code{COUNTIF} functions.  Shows the total number of elements in any number of data objects altogether or that match a condition.\n#'\n#'@param ... an arbitrary number of \\code{R} objects\n#'@param condition a 1 argument condition\n#'@export\n#'@examples\n#'count(c(NA,1,2))\n#'count(c(NA,1,2),is.na)\n#'count(c(NA,1,2),list('A',4),cbind(1,2,3))\n#'count(c(NA,1,2),list('A',4),cbind(1,2,3),condition=is.character)\ncount<-function(...,condition=(function (x) TRUE))\n{\n  data<-c(...)\n  result<-sum(sapply(data, function (x) if(condition(x)) 1 else 0))\n  return(result)\n}",
    "created" : 1406043196234.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4115585709",
    "id" : "3279BC7D",
    "lastKnownWriteTime" : 1406146877,
    "path" : "~/Analytics/Source/rowr/R/rowr.R",
    "project_path" : "R/rowr.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}